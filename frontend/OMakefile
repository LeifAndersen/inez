open build/C
open build/OCaml

BYTE_ENABLED = true
NATIVE_ENABLED = true
OCAMLFLAGS += -thread
USE_OCAMLFIND = true
OCAMLPACKS = core camlp4 camlidl camlp4.lib herelib
INCLUDES = $(CAMLIDL_INCLUDE_PATH)

OCAMLDEP_MODULES_ENABLED = true

OCAML_CLIBS = ../backend/libbct

OCAML_BYTE_LINK_FLAGS = -custom
OCAML_LINK_FLAGS = -linkpkg -ccopt -L$(SCIP_LIB_DIR) -cclib -lscipopt	\
        -cclib -lstdc++ -cclib -lcamlidl

private.EXT_COBJ = .o

scip_idl.ml scip_idl.mli scip_idl.h scip_idl_stubs.c: scip_idl.idl
    camlidl -header scip_idl.idl

# copied from
#   http://www.camlcity.org/knowledge/kb_001_omake_recipes.html

Camlp4o(module) =
    section
        OCAMLPACKS += camlp4
        OCAMLDEPFLAGS += -pp camlp4of
        OCAMLFLAGS += -pp camlp4of
        $(module).cmi:
        $(module).cmo:
        $(module).o:
        $(module).cmx:

Camlp4o_sexplib(module) =
    section
        OCAMLPACKS += camlp4
        OCAMLDEPFLAGS += -pp "camlp4of -I `ocamlfind query type_conv` -I `ocamlfind query sexplib` pa_type_conv.cma pa_sexp_conv.cma"
        OCAMLFLAGS += -pp "camlp4of -I `ocamlfind query type_conv` -I `ocamlfind query sexplib` pa_type_conv.cma pa_sexp_conv.cma"
        $(module).cmi:
        $(module).cmo:
        $(module).o:
        $(module).cmx:

Camlp4o_here(module) =
    section
        OCAMLPACKS += camlp4
        OCAMLDEPFLAGS += -pp "camlp4of -I `ocamlfind query herelib` pa_herelib.cma"
        OCAMLFLAGS += -pp "camlp4of -I `ocamlfind query herelib` pa_herelib.cma"
        $(module).cmi:
        $(module).cmo:
        $(module).o:
        $(module).cmx:

# I copied the function below from OCaml.om, and extended it to link
# against .o files generated from .c sources. I also reordered
# parameters to ocamlopt: $(OCAML_LINK_FLAGS) should be after
# $(COFILES) .

public.MyOCamlProgram(name, files, cfiles) =

    private.CMOFILES = $(addsuffix .cmo, $(files))
    private.CMXFILES = $(addsuffix .cmx, $(files))
    private.OFILES = $(addsuffix $(EXT_OBJ), $(files))

    private.COFILES = $(addsuffix $(EXT_COBJ), $(cfiles))

    private.CMAFILES = $(addsuffix .cma,  $(OCAML_LIBS))
    private.CMXAFILES = $(addsuffix .cmxa, $(OCAML_LIBS))
    private.ARFILES = $(addsuffix $(EXT_LIB), $(OCAML_LIBS))
    private.CMA_OTHER_FILES = $(addsuffix .cma, $(OCAML_OTHER_LIBS))
    private.CMXA_OTHER_FILES = $(addsuffix .cmxa, $(OCAML_OTHER_LIBS))

    private.CLIBS = $(addsuffix $(EXT_LIB), $(OCAML_CLIBS))

    private.name = $(file $(name))

    private.PROG = $(file $(name)$(EXE))
    private.BYTEPROG = $(file $(name).run)
    private.OPTPROG = $(file $(name).opt)

    #
    # Rules to build byte-code and native targets
    #
    $(BYTEPROG): $(CMAFILES) $(CMOFILES) $(CLIBS) $(COFILES)
        $(OCAMLFIND) $(OCAMLLINK) $(LAZY_OCAMLFINDFLAGS)		\
                $(PREFIXED_OCAMLPACKS) $(OCAMLFLAGS) $(OCAMLCFLAGS)	\
                $(PREFIXED_OCAMLINCLUDES) -o $@ $(CMA_OTHER_FILES)	\
                $(CMAFILES) $(OCamlLinkSort $(CMOFILES)) $(COFILES)	\
                $(CLIBS) $(OCAML_LINK_FLAGS) $(OCAML_BYTE_LINK_FLAGS)

    $(OPTPROG): $(CMXAFILES) $(ARFILES) $(CMXFILES) $(OFILES) $(CLIBS) \
            $(COFILES)
        $(OCAMLFIND) $(OCAMLOPTLINK) $(LAZY_OCAMLFINDFLAGS)		\
                $(PREFIXED_OCAMLPACKS) $(OCAMLFLAGS) $(OCAMLOPTFLAGS)	\
                $(PREFIXED_OCAMLINCLUDES) -o $@ $(CMXA_OTHER_FILES)	\
                $(CMXAFILES) $(COFILES) $(OCamlLinkSort $(CMXFILES))	\
                $(CLIBS) $(OCAML_LINK_FLAGS)				\
                $(OCAML_NATIVE_LINK_FLAGS)

    #
    # Link the actual executables.
    # Always prefer native executables.
    #
    if $(NATIVE_ENABLED)
        $(PROG): $(OPTPROG)
            ln-or-cp $< $@
    else
        $(PROG): $(BYTEPROG)
            ln-or-cp $< $@

    return $(array $(PROG), \
                   $(if $(NATIVE_ENABLED), $(OPTPROG)), \
                   $(if $(BYTE_ENABLED), $(BYTEPROG)))

public.OCamlTop(name, files, cfiles) =

    private.CMOFILES = $(addsuffix .cmo, $(files))
    private.OFILES = $(addsuffix $(EXT_OBJ), $(files))

    private.COFILES = $(addsuffix $(EXT_COBJ), $(cfiles))

    private.CMAFILES = $(addsuffix .cma,  $(OCAML_LIBS))
    private.ARFILES = $(addsuffix $(EXT_LIB), $(OCAML_LIBS))
    private.CMA_OTHER_FILES = $(addsuffix .cma, $(OCAML_OTHER_LIBS))

    private.CLIBS = $(addsuffix $(EXT_LIB), $(OCAML_CLIBS))
    private.OCAMLPACKS = $(filter-out camlp4%, $(OCAMLPACKS))
    private.PREFIXED_OCAMLPACKS =\
        $`(if $(and $(USE_OCAMLFIND) $(gt $(length $(OCAMLPACKS)), 0)),\
            -package $(string $(concat \,, $(OCAMLPACKS))),\
            $(EMPTY))

    private.name = $(file $(name))
    private.PROG = $(file $(name).top)

    # FIXME: hardcoded dynlink.cma and camlp4o.cma

    $(PROG): $(CMAFILES) $(CMOFILES) $(CLIBS) $(COFILES)
        $(OCAMLFIND) $(OCAMLMKTOP) $(LAZY_OCAMLFINDFLAGS) dynlink.cma	\
        -I +camlp4 camlp4o.cma $(PREFIXED_OCAMLPACKS) $(OCAMLFLAGS)	\
        $(OCAMLCFLAGS) $(PREFIXED_OCAMLINCLUDES) -o $@			\
        $(CMA_OTHER_FILES) $(CMAFILES) $(OCamlLinkSort $(CMOFILES))	\
        $(COFILES) $(CLIBS) $(OCAML_LINK_FLAGS)				\
        $(OCAML_BYTE_LINK_FLAGS)

    return $(PROG)

# TODO: add target for preloaded camlp4; the recipe is
# OCAMLFIND_COMMANDS='ocamlmktop=mkcamlp4' \
# ocamlfind ocamlmktop \
#     -thread -linkpkg -package compiler-libs.toplevel,core \
#     -I +camlp4 camlp4o.cma lang_concrete.cmo \
#     -o inez.pp -custom

Camlp4o_sexplib(lang_types)
Camlp4o_here(solver)
Camlp4o_here(scip)

Camlp4o(lang_concrete)

MyOCamlProgram(inez, \
               scip util formula \
               lang_types lang_ids lang_abstract solver \
	       smtlib_lexer smtlib_parser smtlib_solver \
               main,  \
               scip_idl_stubs)

OCamlTop(inez, \
         scip formula \
         lang_types lang_ids lang_abstract lang_concrete solver, \
         camlidl_dummy scip_idl_stubs)

.PHONY: clean

clean:
    rm -f *.o *.cm[iox] smtlib_lexer.ml inez inez.opt inez.run	\
            inez.top *.omc scip_idl.ml scip_idl.mli scip_idl.h	\
            scip_idl_stubs.c
